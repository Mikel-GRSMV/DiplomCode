STEP-1
------------------------------------------------------------------------------------------------------------------------
Подключенные зависимости:
spring-boot-starter-web -
spring-boot-starter-freemarker -
postgresql
spring-boot-starter-security -
spring-boot-starter-data-jpa -

STEP-2
------------------------------------------------------------------------------------------------------------------------
пропишу функционал для добавления/удаления/просмотр списка всех товара(ов):

Для хранения данных нужно создать модель: models.Product
@Data создаст для класса конструктор по умолчанию, getter/setter, equals()/hashCode(), toString()
@AllArgsConstructor создаст конструктор со всеми полями класса

Для работы с данными создам сервис: services.ProductService
здесь прописывается логика работы с продуктами. Просмотр, удаление, добавление продукта:

Для вывода на страничку и работы с сервисом я в Controller должен инжектировать сервис:

После я должен в главный метод, который выводит главную страничку передать модель - (Model model).
Model - нужен для передачи параметров в шаблонизатор и далее мы можем каким-то образом работать с данными,
которые мы передаем с Controller:
model.addAttribute("products", productService.getListAllProducts());
"products" - Key
productService.getListAllProducts() - Value
Таким образом мы передадим список всех товаров.
На страничке получим наш список:
<#list products as product> это итератор на html/ftlh, он получает ключ с Controller, а по нему и список продуктов ->
итерируется по нему.

@PathVariable Long id - получает id из ссылки "/product/delete/{id}".


STEP-3
------------------------------------------------------------------------------------------------------------------------
Подключение к БД на примере PostgreSQL
1. создается schema в БД - AvitoApp
2. Пропишем настройки в application.properties:
spring.datasource.url=jdbc:postgresql://localhost:5737/AvitoApp
spring.datasource.username=mihail
spring.datasource.password=662607
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

@Entity - говорит, что данный класс является сущностью БД.
@Table - таблица в БД.

Для выполнения простых операций в БД создается интерфейс repositories.ProductRepository
Данный интерфейс наследуется от extends JpaRepository<Product, Long>
Product - сущность с которой мы работаем.
Long - тип данных идентификатора сущности.

Далее в сервис нужно заинжектить репозиторий.

@Slf4j - для логирования

Изменения в ProductController%


STEP-4
------------------------------------------------------------------------------------------------------------------------
Добавить возможность добавления фотографий
создается модель/класс image, которая будет лежать в БД models.Image

@Lob - данное поле в БД будет хранить в типе long blob, можно и так @Column(columnDefinition = "LONGBLOB")

Для модели создается репозиторий.

изменение в классе ProductService, меняем метод saveProduct для возможности добавления фотографий.

изменения в классе ProductController, так как изменен метод saveProduct().

изменение самой формы добавления

Пропишу Controller, который будет принимать фотографию. Это будет RestController, так как возвращать представление нам
не нужно.


STEP-5
------------------------------------------------------------------------------------------------------------------------
Добавление Spring security.

после добавления spring-boot-starter-security уже из коробки предоставляет базовую защиту.

создам модель пользователя users.User

в SpringSecurity предусмотрен такой интерфейс как UserDetails его должен имплементировать класс пользователя ->
-> имплементировать абсолютно все методы.

создам репозиторий для данной модели.

создадим сервис с базовой логикой регистрации.

пропишу UserController.

добавляю класс, который называется, грубо говоря Spring-security конфигурация configurations.SecurityConfig.

создам еще один сервис CustomUserDetailsService - spring security мысли не читает и он не может понять как
конкретно подгружать пользователей по их UserName и моя задача это показать ему. Я должен от имплементировать
его от UserDetailsService и переопределить его единственный метод loadByUserName.

STEP-6
------------------------------------------------------------------------------------------------------------------------
Отношения между продуктами и пользователями

теперь для добавления товара, нужно зарегистрироваться в приложении и добавление товара будет от лица определенного
пользователя + скрою доступ к полям для некоторых пользователей.

добавил поля в соответсвующий сущности.

переделаем ProductService.saveProduct().

внесли правки в ProductController.

правки представлений.

удалить кнопку удалить из product-info:
   <form action="/product/delete/${product.id}" method="post">
   <input type="hidden" name="_csrf" value="${_csrf.token}">
       <input type="submit" value="Удалить товар"/>
</form>

STEP-7
------------------------------------------------------------------------------------------------------------------------
Добавление панели администратора

Добавление раз ограничение по полям. Добавим панель администратора, чтобы пользователи имели какие либо роли.

Добавлю возможность переходить на страницу пользователя. создам метод UserController.userInfo().

command shift f9 - для быстрого фикса представления

начну работу по раз ограничению по ролям:

создам отдельный контроллер AdminController.

создам представление админ.

добавлена аннотация в SecurityConfig - @EnableGlobalMethodSecurity(prePostEnabled = true)
и указать, что класс AdminController его методы будут доступны только авторизованным пользователям -
@PreAuthorize("hasAuthority('$ROLE_ADMIN')")

STEP-8
------------------------------------------------------------------------------------------------------------------------
Добавление UI

